def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True



# Проверка на числа ≤ 1:
# Простое число должно быть больше 1. Если n ≤ 1, сразу возвращаем False.
# Проверка делителей от 2 до √n:
# Если у числа есть делитель больше 1 и меньше самого себя, оно не простое.
# Достаточно проверить делители от 2 до √n, потому что если n = a * b, то либо a ≤ √n, либо b ≤ √n.
# Если найден делитель → число не простое:
# Если n делится на какое-то i без остатка (n % i == 0), значит, у числа есть делитель, и оно не простое.
# Если делителей нет → число простое:
# Если цикл завершился без нахождения делителей, число простое


def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr




# Внешний цикл (проходы):
# Количество проходов равно длине массива (n).
# После каждого прохода самый большой элемент "всплывает" в конец.
# Внутренний цикл (сравнение пар):
# На каждом шаге сравниваются два соседних элемента.
# Если текущий элемент (arr[j]) больше следующего (arr[j + 1]), они меняются местами.
# Оптимизация (уменьшение проверяемой области):
# осле каждого прохода последний элемент уже на своём месте, поэтому внутренний цикл проверяет только n - i - 1 элементов.
# После всех проходов массив становится отсортированным по возрастанию.


